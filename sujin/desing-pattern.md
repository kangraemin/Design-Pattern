# 1. 디자인패턴 소개

디자인패턴의 세계에 오신것을 환영합니다.

누군가 이미 여러분의 문제를 해결해놓았습니다. 그 문제를 해결했던 다른 개발자들이 익혔던 지혜와 교훈을 왜 활용해야했는지, 그리고 어떻게 활용할 수 있는지에 대해 배우게될것입니다.

### 문제는 간단한 simUDuck 애플리케이션을 시작했습니다.

오리애플리케이션을 클래스와 객체지향기법을 활용해서 시작했습니다. 근데, 경쟁회사가 생겼습니다..!

### 이제는 오리들이 날수 있도록 해야합니다.

오리를 날아다니게 해야한다고 임원진들이 말합니다. 객체지향도 하는데, 문제없다고 조는 말합니다.

### 심각한 문제 등장

오리 인형까지 날아다니는 문제가 있었습니다.

Duck이란 슈퍼크래스에 fly를 만들어주고, 서브클래스들 모두에게 이 fly기능이 생긴거죠.

### 조는 상속에 대해 생각합니다.

fly에 아무것도 하지 않도록 오버라이드 했으면 됐잖아..?

### 인터페이스는 어떨까요?

상속으로 해결하지 않고 인터페이스로 해결할수도 있지 않을까요? Flyable이라는 인터페이스를 만들면 좋을것입니다.

### 조의 입장에서?

모든 서브클래스에서 날지 않기 때문에 상속을 사용하는 것이 올바를 해결책은 아닐것입니다.

### 문제를 파악해보자.

Flyable을 사용하는 방법은 처음에는 괜찮아보였지만, 자바 인터페이스에서는 구현된 코드가 전혀 들어가지 않기 때무에 코드 재사용을 할수 없단 단점이 있습니다. 즉 한 행동을 바꿀 때마다 일일히 서브클래스들을 수정해줘야합니다.

모든 패턴은 "시스템의 일부분을 다른 부분과 독립적으로 변화시킬수 있는 방법을 제공하기" 위한 것입니다. 그럼 Duck 클래스에서 오리의 행동을 뽑아내볼까요?

### 바뀌는 부분과 그렇지 않은 부분 분리하기

변화하는 부분과 그렇지 않은 부분을 분리하려면 두개의 클래스 집합을 만들어야합니다. 하나는 "나는것"과 관련된 것과 "꽥꽥거리는 것"과 관련된 부분이죠. 그리고 저런것을 안하는 Duck 클래스를 하나 만들어야합니다.

### 오리의 행동 디자인

나는 행동과 꽥꽥거리는 행동을 구현하는 클래스는 어떻게 디자인해야할까?

디자인 원칙 : 구현이 아닌 인터페이스에 맞춰서 프로그래밍한다.

각 행동은 인터페이스로 표현하고, 행동을 구현할 때는 이런 인터페이스를 구현하겠습니다. 나는 행동과 꽥꽥거리는 행동은 이제 Duck클래스에 구현하거나 서브클래스 자체에서 별도로 구현하는 방법하고는 상반된 방법입니다.

이 방법은 지금까지의 Duck 클래스 구현에 의존하거나 서브클래스 자체에서 별도로 구현하는 방법과 완전 딴 이야기입ㄴ다. 전에는 특정 구현에 의존했습니다. 특정 구현에 의지했기 때문에 행동을 변경할 여지가 없었죠.

새로운 디자인원칙을 적용하면, 인터페이스로 표현하는 행동을 사용합니다.

### 인터페이스에 맞춰서 프로그래밍 한다는 것

인터페이스에 맞춰서 프로그래밍 한다는 것는 사실 상위 형식에 맞춰서 프로그래밍 한다는 뜻입니다. 여기서 인터페이스는 자바의 인터페이스 구조를 꼭 지칭하는 것은 아니고, 의미로 존재하는 것일수 있습니다.

### Duck의 행동을 구현하는 방법

여기에서는 FlyBehavior와 QuackBehavior라는 두 인터페이스를 사용합니다. 그리고 구체적인 행동을 구현하는 클래스들이 있습니다.

FlyBehavior

- FlyWithWings
- FlyNoWings

QuackBehavior

- Quack
- Squack
- MuteQuack

---

### Duck의 행동 통합하기

가장 중요한 점은 이제 Duck에서 나는 행동과 꽥꽥 소리를 내는 행동을 Duck 클래스에서 정의한 메소드를 써서 구현하지 않고 다른 클래스에 위임한다는 것입니다.

**어떻게 하는걸까요?**

1. 우선 Duck 클래스에 FlyBehavior, QuackBehavior라는 두개의 인터페이스 형식의 인스턴스 변수를 추가합니다. 각 오리객체는 이 변수에 특정 행동 형식에 대한 레퍼런스를 다형적으로 설정합니다.
    
    그리고, 나는 행동과 꽥꽥거리는 행동은 각 인터페이스로 옮겨놨기 때문에 Duck의 fly()와 quack() 메소드를 제거합니다. 그 대신, Duck 클래스에 performFly()와 performDuck()이라는 메소드를 집어넣습니다.
    
2. performDuck() 구현
    
    ```jsx
    public class Duck {
    	QuackBehavior quackBehavior;
    	...
    	public void performQuack () {
    		quackBehavior.quack();
    	}
    }
    ```
    
    꽤 간단하죠? 꽥꽥 거리는 행동을 하고 싶을 땐 quackBehavior에 의해 참조된 객체에서 소리내면 됩니다.
    
3. 이제 flyBehavior와 quackBehavior 인스턴스 변수를 설정하는 방법에 대해 생각해볼 차례입니다.
    
    ```jsx
    public class MallarDuck extends Duck {
    	// MallarDuck은 quackBehavior와 flyBehavior 인스턴스 변수를 상속받음
    	public MallarDuck() {
    		quackBehavior = new Quack();
    		flyBehavior = new FlyWithWings();
    	}
    	public void display() {
    		System.out.println('저는 물오리입니다')
    	}
    }
    ```
    
     이 물오리 클래스는 오리 꽥꽥 소리를 낼수 있는것입니다.
    
    잠깐잠깐, 특정 구현에 맞춰서 프로그래밍 하면 안된다 하지 않았다는 지적을 할수 있을 텐데요. 하지만 여기선 행동을 구상클래스로 설정하고 있긴하지만, 실행시 쉽게 바꿀수 있습니다. 따라서 이 코드는 상당히 유연하다고 할수 있죠.
    

---

참고 문서

[JAVA] 자바 인터페이스란?(Interface)_이 글 하나로 박살내자 ( [링크](https://limkydev.tistory.com/197) )

[JAVA] 자바 추상클래스란? ( [링크](https://limkydev.tistory.com/188) )
